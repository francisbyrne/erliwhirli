<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Erly Whirly Thirsdly Mini</title>
    <link rel="icon" href="favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Source+Serif+4:ital,wght@0,300;0,400;1,300&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --ink: #1a1008;
        --paper: #f7f2e8;
        --accent: #b5451b;
        --cell-size: 58px;
      }

      body {
        background: var(--paper);
        color: var(--ink);
        font-family: "Source Serif 4", Georgia, serif;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px 60px;
      }

      header {
        text-align: center;
        margin-bottom: 36px;
      }
      header h1 {
        font-family: "Playfair Display", Georgia, serif;
        font-size: 2.4rem;
        letter-spacing: 0.12em;
        line-height: 1;
      }
      header .byline {
        margin-top: 6px;
        font-size: 0.78rem;
        letter-spacing: 0.25em;
        text-transform: uppercase;
        color: var(--accent);
      }

      .grid-wrapper {
        border: 3px solid var(--ink);
        display: inline-block;
        line-height: 0;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(5, var(--cell-size));
        grid-template-rows: repeat(5, var(--cell-size));
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        position: relative;
        border: 1.5px solid var(--ink);
      }
      .cell.blocked {
        background: var(--ink);
        overflow: hidden;
      }
      .cell.blocked img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .cell input {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
        text-align: center;
        font-family: "Playfair Display", Georgia, serif;
        font-size: 1.55rem;
        font-weight: 700;
        color: var(--ink);
        text-transform: uppercase;
        outline: none;
        caret-color: transparent;
        cursor: default;
        padding-top: 8px;
        transition: background 0.1s;
      }
      .cell input.hl-word {
        background: #e8d9b0;
      }
      .cell input.hl-active {
        background: #f0c040;
      }

      .cell .num {
        position: absolute;
        top: 3px;
        left: 4px;
        font-family: "Source Serif 4", serif;
        font-size: 0.6rem;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
      }

      .error-msg {
        margin-top: 16px;
        width: 100%;
        max-width: 310px;
        background: #fff0eb;
        border: 2px solid var(--accent);
        padding: 10px 16px;
        font-family: "Playfair Display", serif;
        font-size: 0.95rem;
        color: var(--accent);
        text-align: center;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .error-msg.show {
        visibility: visible;
        opacity: 1;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        20% {
          transform: translateX(-7px);
        }
        40% {
          transform: translateX(7px);
        }
        60% {
          transform: translateX(-4px);
        }
        80% {
          transform: translateX(4px);
        }
      }
      .grid-wrapper.shake {
        animation: shake 0.5s ease;
      }

      .clues-section {
        margin-top: 32px;
        width: 100%;
        max-width: 310px;
        border-top: 2px solid var(--ink);
        padding-top: 20px;
      }
      .clues-cols {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
      }
      .clue-group h2 {
        font-family: "Playfair Display", Georgia, serif;
        font-size: 0.95rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        margin-bottom: 10px;
        color: var(--accent);
        border-bottom: 1px solid #c9b99a;
        padding-bottom: 4px;
      }
      .clue-group ul {
        list-style: none;
      }
      .clue-group li {
        font-size: 0.82rem;
        line-height: 1.5;
        margin-bottom: 8px;
        cursor: pointer;
        transition: color 0.15s;
      }
      .clue-group li:hover {
        color: var(--accent);
      }
      .clue-group li.active {
        color: var(--accent);
        font-weight: 600;
      }
      .clue-group li .cn {
        font-family: "Playfair Display", serif;
        font-weight: 700;
        margin-right: 4px;
        color: var(--accent);
      }

      .victory-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(26, 16, 8, 0.55);
        backdrop-filter: blur(3px);
        z-index: 100;
        align-items: center;
        justify-content: center;
      }
      .victory-overlay.show {
        display: flex;
        animation: fade-in 0.35s ease;
      }
      @keyframes fade-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .victory-card {
        background: var(--paper);
        border: 3px solid var(--ink);
        padding: 44px 52px;
        text-align: center;
        max-width: 340px;
        animation: rise 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      }
      @keyframes rise {
        from {
          transform: translateY(24px) scale(0.95);
          opacity: 0;
        }
        to {
          transform: none;
          opacity: 1;
        }
      }
      .victory-card .trophy {
        font-size: 2.6rem;
        margin-bottom: 16px;
      }
      .victory-card h2 {
        font-family: "Playfair Display", serif;
        font-size: 1.5rem;
        margin-bottom: 12px;
      }
      .victory-card p {
        font-size: 0.9rem;
        color: #5a4030;
        line-height: 1.6;
      }
      .victory-card .time {
        font-family: "Playfair Display", serif;
        font-size: 1.15rem;
        color: var(--accent);
        margin-top: 10px;
        display: block;
      }
      .victory-card .dismiss {
        margin-top: 24px;
        background: var(--ink);
        color: var(--paper);
        border: none;
        padding: 10px 28px;
        font-family: "Source Serif 4", serif;
        font-size: 0.85rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.15s;
      }
      .victory-card .dismiss:hover {
        background: var(--accent);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Erly Whirly Thirsdly Mini</h1>
      <div class="byline">Thursday's Mini Crossword</div>
    </header>

    <div class="grid-wrapper" id="grid-wrapper">
      <div class="grid" id="grid"></div>
    </div>

    <div class="error-msg" id="error-msg">
      ⚠ One or more answers is incorrect — keep going!
    </div>

    <div class="clues-section">
      <div class="clues-cols">
        <div class="clue-group">
          <h2>Across</h2>
          <ul id="clues-across"></ul>
        </div>
        <div class="clue-group">
          <h2>Down</h2>
          <ul id="clues-down"></ul>
        </div>
      </div>
    </div>

    <div class="victory-overlay" id="victory-overlay">
      <div class="victory-card">
        <div class="trophy">✦</div>
        <h2>Puzzle Complete!</h2>
        <p>Congratulations, you completed the puzzle</p>
        <span class="time" id="victory-time"></span>
        <button
          class="dismiss"
          onclick="
            document.getElementById('victory-overlay').classList.remove('show')
          "
        >
          Close
        </button>
      </div>
    </div>

    <script>
      // ─── PUZZLE ───────────────────────────────────────────────────────────────────
      //
      //       c0  c1  c2  c3  c4
      //  r0:   P   L   A   N   T   ← 1-Across: PLANT
      //  r1:   A   ■   R   ■   H
      //  r2:   C   H   O   I   R   ← 2-Across: CHOIR
      //  r3:   E   ■   M   ■   E
      //  r4:   S   T   A   R   E   ← 3-Across: STARE
      //        ↑       ↑       ↑
      //      1-Down  2-Down  3-Down
      //      PACES   AROMA   THREE

      const SOLUTION = [
        ["P", "L", "A", "N", "T"],
        ["A", " ", "R", " ", "H"],
        ["C", "H", "O", "I", "R"],
        ["E", " ", "M", " ", "E"],
        ["S", "T", "A", "R", "E"],
      ];

      const OPEN = [
        [1, 1, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
      ];

      // Words defined explicitly — cells listed in typing order
      const WORDS = [
        {
          id: "1A",
          label: "1",
          dir: "across",
          clue: "A garden plant, or a sneaky scheme",
          cells: [
            { r: 0, c: 0 },
            { r: 0, c: 1 },
            { r: 0, c: 2 },
            { r: 0, c: 3 },
            { r: 0, c: 4 },
          ],
        },
        {
          id: "2A",
          label: "2",
          dir: "across",
          clue: "A group that sings together",
          cells: [
            { r: 2, c: 0 },
            { r: 2, c: 1 },
            { r: 2, c: 2 },
            { r: 2, c: 3 },
            { r: 2, c: 4 },
          ],
        },
        {
          id: "3A",
          label: "3",
          dir: "across",
          clue: "To look at fixedly",
          cells: [
            { r: 4, c: 0 },
            { r: 4, c: 1 },
            { r: 4, c: 2 },
            { r: 4, c: 3 },
            { r: 4, c: 4 },
          ],
        },
        {
          id: "1D",
          label: "1",
          dir: "down",
          clue: "Steps, measured distances",
          cells: [
            { r: 0, c: 0 },
            { r: 1, c: 0 },
            { r: 2, c: 0 },
            { r: 3, c: 0 },
            { r: 4, c: 0 },
          ],
        },
        {
          id: "2D",
          label: "2",
          dir: "down",
          clue: "A pleasant smell",
          cells: [
            { r: 0, c: 2 },
            { r: 1, c: 2 },
            { r: 2, c: 2 },
            { r: 3, c: 2 },
            { r: 4, c: 2 },
          ],
        },
        {
          id: "3D",
          label: "3",
          dir: "down",
          clue: "One more than two",
          cells: [
            { r: 0, c: 4 },
            { r: 1, c: 4 },
            { r: 2, c: 4 },
            { r: 3, c: 4 },
            { r: 4, c: 4 },
          ],
        },
      ];

      // ─── STATE ────────────────────────────────────────────────────────────────────
      let activeWord = WORDS[0];
      let activeCellIdx = 0;
      let startTime = null;
      let puzzleDone = false;
      let hasShaken = false;

      // ─── BUILD GRID ───────────────────────────────────────────────────────────────
      const gridEl = document.getElementById("grid");
      const inputAt = {}; // "r,c" -> <input>

      // Determine clue number label for each cell that starts a word
      const cellLabel = {};
      WORDS.forEach((w) => {
        const { r, c } = w.cells[0];
        const key = `${r},${c}`;
        if (!cellLabel[key] || Number(w.label) < Number(cellLabel[key])) {
          cellLabel[key] = w.label;
        }
      });

      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");

          if (!OPEN[r][c]) {
            cell.classList.add("blocked");
            const img = document.createElement("img");
            img.src = "pugg.webp";
            img.alt = "";
            cell.appendChild(img);
            gridEl.appendChild(cell);
            continue;
          }

          if (cellLabel[`${r},${c}`]) {
            const span = document.createElement("span");
            span.classList.add("num");
            span.textContent = cellLabel[`${r},${c}`];
            cell.appendChild(span);
          }

          const inp = document.createElement("input");
          inp.type = "text";
          inp.autocomplete = "off";
          inp.spellcheck = false;
          cell.appendChild(inp);
          inputAt[`${r},${c}`] = inp;

          // Closures capture r, c correctly here
          inp.addEventListener("mousedown", (e) => {
            e.preventDefault();
            onCellClick(r, c);
          });
          inp.addEventListener("keydown", onKeyDown);
          inp.addEventListener("input", onInput);

          gridEl.appendChild(cell);
        }
      }

      // ─── BUILD CLUE LISTS ─────────────────────────────────────────────────────────
      const clueEls = {}; // word.id -> <li>
      WORDS.forEach((w) => {
        const li = document.createElement("li");
        li.innerHTML = `<span class="cn">${w.label}.</span>${w.clue}`;
        li.addEventListener("click", () => activateWord(w, 0));
        document
          .getElementById(w.dir === "across" ? "clues-across" : "clues-down")
          .appendChild(li);
        clueEls[w.id] = li;
      });

      // Separate store for the actual letter at each cell, so we can clear
      // the focused input's .value (for mobile) without losing the displayed letter.
      const gridValues = {}; // "r,c" -> uppercase letter or ''

      function setGridValue(r, c, letter) {
        gridValues[`${r},${c}`] = letter;
        const inp = inputAt[`${r},${c}`];
        if (inp) inp.value = letter;
      }

      function getGridValue(r, c) {
        return gridValues[`${r},${c}`] || "";
      }

      // ─── ACTIVATE WORD ────────────────────────────────────────────────────────────
      function activateWord(word, letterIdx) {
        activeWord = word;
        activeCellIdx = Math.max(0, Math.min(word.cells.length - 1, letterIdx));

        // Highlights
        Object.values(inputAt).forEach((inp) =>
          inp.classList.remove("hl-word", "hl-active"),
        );
        word.cells.forEach(({ r, c }) => {
          const inp = inputAt[`${r},${c}`];
          if (inp) {
            inp.classList.add("hl-word");
            inp.value = getGridValue(r, c);
          }
        });

        const { r, c } = word.cells[activeCellIdx];
        const inp = inputAt[`${r},${c}`];
        if (inp) {
          inp.classList.replace("hl-word", "hl-active");
          inp.focus();
        }

        // Clue list
        Object.values(clueEls).forEach((li) => li.classList.remove("active"));
        clueEls[word.id].classList.add("active");
      }

      function advanceInWord() {
        if (activeCellIdx < activeWord.cells.length - 1) {
          activateWord(activeWord, activeCellIdx + 1);
        }
        // At last cell: stay put
      }

      function retreatInWord() {
        if (activeCellIdx > 0) {
          activateWord(activeWord, activeCellIdx - 1);
        }
      }

      // ─── CLICK HANDLER ────────────────────────────────────────────────────────────
      // Simple rule: if a word STARTS at the clicked cell, activate that word.
      // The only ambiguous cell is (0,0) where both 1A and 1D start — default to 1A.
      // For mid-word cells: stay on current word if it contains the cell, else find one that does.
      function onCellClick(r, c) {
        // Words that start at this cell
        const starters = WORDS.filter(
          (w) => w.cells[0].r === r && w.cells[0].c === c,
        );

        if (starters.length === 1) {
          activateWord(starters[0], 0);
          return;
        }

        if (starters.length > 1) {
          // Only happens at (0,0): 1A and 1D both start here
          // Default to 1A unless it's full and 1D is not
          const wordAcross = starters.find((w) => w.dir === "across");
          const wordDown = starters.find((w) => w.dir === "down");
          if (
            wordAcross &&
            isWordFilled(wordAcross) &&
            wordDown &&
            !isWordFilled(wordDown)
          ) {
            activateWord(wordDown, 0);
          } else {
            activateWord(wordAcross || starters[0], 0);
          }
          return;
        }

        // No word starts here — mid-word cell.
        // If current word contains it, move cursor there.
        const idxInCurrent = activeWord.cells.findIndex(
          (cell) => cell.r === r && cell.c === c,
        );
        if (idxInCurrent !== -1) {
          activateWord(activeWord, idxInCurrent);
          return;
        }

        // Otherwise switch to whichever word contains this cell.
        for (const w of WORDS) {
          const idx = w.cells.findIndex((cell) => cell.r === r && cell.c === c);
          if (idx !== -1) {
            activateWord(w, idx);
            return;
          }
        }
      }

      // ─── KEY HANDLER ──────────────────────────────────────────────────────────────
      function onKeyDown(e) {
        if (e.key === "Backspace") {
          e.preventDefault();
          const { r, c } = activeWord.cells[activeCellIdx];
          if (getGridValue(r, c)) {
            setGridValue(r, c, "");
            // Keep input empty (it's already cleared in activateWord)
          } else {
            retreatInWord();
            const prev = activeWord.cells[activeCellIdx];
            setGridValue(prev.r, prev.c, "");
            // The newly focused cell is now active and its input was cleared by activateWord
          }
          return;
        }

        if (e.key === "ArrowRight") {
          e.preventDefault();
          if (activeWord.dir === "across") advanceInWord();
        }
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          if (activeWord.dir === "across") retreatInWord();
        }
        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (activeWord.dir === "down") advanceInWord();
        }
        if (e.key === "ArrowUp") {
          e.preventDefault();
          if (activeWord.dir === "down") retreatInWord();
        }
      }

      // ─── INPUT HANDLER ────────────────────────────────────────────────────────────
      function onInput(e) {
        // e.data is the character the user just typed (reliable on mobile).
        // Fall back to reading inp.value if e.data is unavailable.
        const raw = e.data ?? e.target.value;
        if (!raw) return;

        const letter = raw
          .replace(/[^a-zA-Z]/g, "")
          .slice(-1)
          .toUpperCase();
        if (!letter) {
          // Restore the stored value if something non-alphabetic was entered
          const { r, c } = activeWord.cells[activeCellIdx];
          e.target.value = getGridValue(r, c);
          return;
        }

        if (!startTime) startTime = Date.now();

        const { r, c } = activeWord.cells[activeCellIdx];
        setGridValue(r, c, letter);

        advanceInWord();
        checkComplete();
      }

      // ─── COMPLETION CHECK ─────────────────────────────────────────────────────────
      function isWordFilled(word) {
        return word.cells.every(({ r, c }) => getGridValue(r, c) !== "");
      }

      function checkComplete() {
        if (puzzleDone) return;

        // Sync any inp.value that may be ahead of gridValues (can happen on mobile)
        Object.keys(inputAt).forEach((key) => {
          const [r, c] = key.split(",").map(Number);
          const inp = inputAt[key];
          const displayed = inp.value
            .replace(/[^a-zA-Z]/g, "")
            .slice(-1)
            .toUpperCase();
          if (displayed && displayed !== getGridValue(r, c)) {
            gridValues[key] = displayed;
          }
        });

        const allFilled = Object.keys(inputAt).every((key) => {
          const [r, c] = key.split(",").map(Number);
          return getGridValue(r, c) !== "";
        });
        if (!allFilled) return;

        const allCorrect = Object.keys(inputAt).every((key) => {
          const [r, c] = key.split(",").map(Number);
          return getGridValue(r, c) === SOLUTION[r][c];
        });

        const errorEl = document.getElementById("error-msg");
        const gridWrap = document.getElementById("grid-wrapper");

        if (allCorrect) {
          puzzleDone = true;
          errorEl.classList.remove("show");
          const secs = Math.round((Date.now() - startTime) / 1000);
          const timeStr =
            secs < 60
              ? `in ${secs} second${secs === 1 ? "" : "s"}`
              : `in ${Math.floor(secs / 60)}m ${secs % 60}s`;
          document.getElementById("victory-time").textContent = timeStr;
          document.getElementById("victory-overlay").classList.add("show");
        } else {
          errorEl.classList.add("show");
          if (!hasShaken) {
            hasShaken = true;
            void gridWrap.offsetWidth;
            gridWrap.classList.add("shake");
            gridWrap.addEventListener(
              "animationend",
              () => gridWrap.classList.remove("shake"),
              { once: true },
            );
          }
        }
      }

      // ─── INIT ─────────────────────────────────────────────────────────────────────
      activateWord(WORDS[0], 0);
    </script>
  </body>
</html>
