<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Erly Whirly Thirsdly Mini</title>
    <link rel="icon" href="favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Source+Serif+4:ital,wght@0,300;0,400;1,300&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --ink: #1a1008;
        --paper: #f7f2e8;
        --accent: #b5451b;
        --cell-size: 58px;
      }

      body {
        background: var(--paper);
        color: var(--ink);
        font-family: "Source Serif 4", Georgia, serif;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px 60px;
      }

      header {
        text-align: center;
        margin-bottom: 36px;
      }
      header h1 {
        font-family: "Playfair Display", Georgia, serif;
        font-size: 2.4rem;
        letter-spacing: 0.12em;
        line-height: 1;
      }
      header .byline {
        margin-top: 6px;
        font-size: 0.78rem;
        letter-spacing: 0.25em;
        text-transform: uppercase;
        color: var(--accent);
      }

      /* ── GRID ── */
      .grid-wrapper {
        border: 3px solid var(--ink);
        display: inline-block;
        line-height: 0;
        position: relative;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(5, var(--cell-size));
        grid-template-rows: repeat(5, var(--cell-size));
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        position: relative;
        border: 1.5px solid var(--ink);
        cursor: text;
        user-select: none;
        -webkit-user-select: none;
      }
      .cell.blocked {
        background: var(--ink);
        overflow: hidden;
        cursor: default;
      }
      .cell.blocked img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* Letter display inside white cells */
      .cell .letter {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding-top: 6px; /* nudge down slightly for clue number */
        font-family: "Playfair Display", Georgia, serif;
        font-size: 1.55rem;
        font-weight: 700;
        color: var(--ink);
        text-transform: uppercase;
        pointer-events: none;
      }
      .cell.hl-word {
        background: #e8d9b0;
      }
      .cell.hl-active {
        background: #f0c040;
      }

      .cell .num {
        position: absolute;
        top: 3px;
        left: 4px;
        font-family: "Source Serif 4", serif;
        font-size: 0.6rem;
        pointer-events: none;
        z-index: 2;
        line-height: 1;
      }

      /* Single hidden input that captures all typing */
      #capture {
        position: fixed;
        opacity: 0;
        width: 1px;
        height: 1px;
        top: 0;
        left: 0;
        pointer-events: none;
        font-size: 16px; /* prevents iOS zoom */
      }

      /* ── ERROR ── */
      .error-msg {
        margin-top: 16px;
        width: 100%;
        max-width: 310px;
        background: #fff0eb;
        border: 2px solid var(--accent);
        padding: 10px 16px;
        font-family: "Playfair Display", serif;
        font-size: 0.95rem;
        color: var(--accent);
        text-align: center;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s;
      }
      .error-msg.show {
        visibility: visible;
        opacity: 1;
      }

      /* ── SHAKE ── */
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        20% {
          transform: translateX(-7px);
        }
        40% {
          transform: translateX(7px);
        }
        60% {
          transform: translateX(-4px);
        }
        80% {
          transform: translateX(4px);
        }
      }
      .grid-wrapper.shake {
        animation: shake 0.5s ease;
      }

      /* ── CLUES ── */
      .clues-section {
        margin-top: 32px;
        width: 100%;
        max-width: 310px;
        border-top: 2px solid var(--ink);
        padding-top: 20px;
      }
      .clues-cols {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
      }
      .clue-group h2 {
        font-family: "Playfair Display", Georgia, serif;
        font-size: 0.95rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        margin-bottom: 10px;
        color: var(--accent);
        border-bottom: 1px solid #c9b99a;
        padding-bottom: 4px;
      }
      .clue-group ul {
        list-style: none;
      }
      .clue-group li {
        font-size: 0.82rem;
        line-height: 1.5;
        margin-bottom: 8px;
        cursor: pointer;
        transition: color 0.15s;
      }
      .clue-group li:hover {
        color: var(--accent);
      }
      .clue-group li.active {
        color: var(--accent);
        font-weight: 600;
      }
      .clue-group li .cn {
        font-family: "Playfair Display", serif;
        font-weight: 700;
        margin-right: 4px;
        color: var(--accent);
      }

      /* ── VICTORY ── */
      .victory-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(26, 16, 8, 0.55);
        backdrop-filter: blur(3px);
        z-index: 100;
        align-items: center;
        justify-content: center;
      }
      .victory-overlay.show {
        display: flex;
        animation: fade-in 0.35s ease;
      }
      @keyframes fade-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .victory-card {
        background: var(--paper);
        border: 3px solid var(--ink);
        padding: 44px 52px;
        text-align: center;
        max-width: 340px;
        animation: rise 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      }
      @keyframes rise {
        from {
          transform: translateY(24px) scale(0.95);
          opacity: 0;
        }
        to {
          transform: none;
          opacity: 1;
        }
      }
      .victory-card .trophy {
        font-size: 2.6rem;
        margin-bottom: 16px;
      }
      .victory-card h2 {
        font-family: "Playfair Display", serif;
        font-size: 1.5rem;
        margin-bottom: 12px;
      }
      .victory-card p {
        font-size: 0.9rem;
        color: #5a4030;
        line-height: 1.6;
      }
      .victory-card .time {
        font-family: "Playfair Display", serif;
        font-size: 1.15rem;
        color: var(--accent);
        margin-top: 10px;
        display: block;
      }
      .victory-card .dismiss {
        margin-top: 24px;
        background: var(--ink);
        color: var(--paper);
        border: none;
        padding: 10px 28px;
        font-family: "Source Serif 4", serif;
        font-size: 0.85rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        cursor: pointer;
        transition: background 0.15s;
      }
      .victory-card .dismiss:hover {
        background: var(--accent);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Erly Whirly Thirsdly Mini</h1>
      <div class="byline">Thursday's Mini Crossword</div>
    </header>

    <!-- Single hidden input — permanently focused, captures all typing -->
    <input
      id="capture"
      type="text"
      autocomplete="off"
      autocorrect="off"
      autocapitalize="characters"
      spellcheck="false"
      inputmode="text"
    />

    <div class="grid-wrapper" id="grid-wrapper">
      <div class="grid" id="grid"></div>
    </div>

    <div class="error-msg" id="error-msg">
      ⚠ One or more answers is incorrect — keep going!
    </div>

    <div class="clues-section">
      <div class="clues-cols">
        <div class="clue-group">
          <h2>Across</h2>
          <ul id="clues-across"></ul>
        </div>
        <div class="clue-group">
          <h2>Down</h2>
          <ul id="clues-down"></ul>
        </div>
      </div>
    </div>

    <div class="victory-overlay" id="victory-overlay">
      <div class="victory-card">
        <div class="trophy">✦</div>
        <h2>Puzzle Complete!</h2>
        <p>Congratulations, you completed the puzzle</p>
        <span class="time" id="victory-time"></span>
        <button
          class="dismiss"
          onclick="
            document.getElementById('victory-overlay').classList.remove('show')
          "
        >
          Close
        </button>
      </div>
    </div>

    <script>
      // ─── PUZZLE ───────────────────────────────────────────────────────────────────
      //
      //       c0  c1  c2  c3  c4
      //  r0:   P   L   A   N   T   ← 1-Across: PLANT
      //  r1:   A   ■   R   ■   H
      //  r2:   C   H   O   I   R   ← 2-Across: CHOIR
      //  r3:   E   ■   M   ■   E
      //  r4:   S   T   A   R   E   ← 3-Across: STARE
      //        ↑       ↑       ↑
      //      1-Down  2-Down  3-Down
      //      PACES   AROMA   THREE

      const SOLUTION = [
        ["D", "E", "N", "S", "E"],
        ["I", " ", "U", " ", "L"],
        ["D", "U", "D", "U", "M"],
        ["I", " ", "E", " ", "O"],
        ["S", "S", "S", "S", "S"],
      ];

      const OPEN = [
        [1, 1, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
        [1, 0, 1, 0, 1],
        [1, 1, 1, 1, 1],
      ];

      const WORDS = [
        {
          id: "1A",
          label: "1",
          dir: "across",
          clue: "Concentrated idiot",
          cells: [
            { r: 0, c: 0 },
            { r: 0, c: 1 },
            { r: 0, c: 2 },
            { r: 0, c: 3 },
            { r: 0, c: 4 },
          ],
        },
        {
          id: "2A",
          label: "2",
          dir: "across",
          clue: "Pink panther intro",
          cells: [
            { r: 2, c: 0 },
            { r: 2, c: 1 },
            { r: 2, c: 2 },
            { r: 2, c: 3 },
            { r: 2, c: 4 },
          ],
        },
        {
          id: "3A",
          label: "3",
          dir: "across",
          clue: "Gas leak noise",
          cells: [
            { r: 4, c: 0 },
            { r: 4, c: 1 },
            { r: 4, c: 2 },
            { r: 4, c: 3 },
            { r: 4, c: 4 },
          ],
        },
        {
          id: "1D",
          label: "1",
          dir: "down",
          clue: "Catch them as a slightly less evil Uber equivalent",
          cells: [
            { r: 0, c: 0 },
            { r: 1, c: 0 },
            { r: 2, c: 0 },
            { r: 3, c: 0 },
            { r: 4, c: 0 },
          ],
        },
        {
          id: "2D",
          label: "2",
          dir: "down",
          clue: "Send them to your lover",
          cells: [
            { r: 0, c: 2 },
            { r: 1, c: 2 },
            { r: 2, c: 2 },
            { r: 3, c: 2 },
            { r: 4, c: 2 },
          ],
        },
        {
          id: "3D",
          label: "3",
          dir: "down",
          clue: "Verbal red puppet toys who crave to be tickled",
          cells: [
            { r: 0, c: 4 },
            { r: 1, c: 4 },
            { r: 2, c: 4 },
            { r: 3, c: 4 },
            { r: 4, c: 4 },
          ],
        },
      ];

      // ─── STATE ────────────────────────────────────────────────────────────────────
      let activeWord = WORDS[0];
      let activeCellIdx = 0;
      const gridValues = {}; // "r,c" -> uppercase letter or ''
      let startTime = null;
      let puzzleDone = false;
      let hasShaken = false;

      // ─── HELPERS ──────────────────────────────────────────────────────────────────
      function getVal(r, c) {
        return gridValues[`${r},${c}`] || "";
      }
      function setVal(r, c, letter) {
        gridValues[`${r},${c}`] = letter;
        const el = document.querySelector(
          `.cell[data-r="${r}"][data-c="${c}"] .letter`,
        );
        if (el) el.textContent = letter;
      }
      function isWordFilled(word) {
        return word.cells.every(({ r, c }) => getVal(r, c) !== "");
      }

      // ─── BUILD GRID ───────────────────────────────────────────────────────────────
      const gridEl = document.getElementById("grid");
      const cellEl = {}; // "r,c" -> .cell div

      const cellLabel = {};
      WORDS.forEach((w) => {
        const { r, c } = w.cells[0];
        const key = `${r},${c}`;
        if (!cellLabel[key] || Number(w.label) < Number(cellLabel[key]))
          cellLabel[key] = w.label;
      });

      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.r = r;
          cell.dataset.c = c;

          if (!OPEN[r][c]) {
            cell.classList.add("blocked");
            const img = document.createElement("img");
            img.src = "pugg.webp";
            img.alt = "";
            cell.appendChild(img);
          } else {
            if (cellLabel[`${r},${c}`]) {
              const num = document.createElement("span");
              num.classList.add("num");
              num.textContent = cellLabel[`${r},${c}`];
              cell.appendChild(num);
            }
            const letter = document.createElement("div");
            letter.classList.add("letter");
            cell.appendChild(letter);

            cell.addEventListener("mousedown", (e) => {
              e.preventDefault();
              onCellClick(r, c);
            });
            cell.addEventListener("touchend", (e) => {
              e.preventDefault();
              onCellClick(r, c);
            });
            cellEl[`${r},${c}`] = cell;
          }

          gridEl.appendChild(cell);
        }
      }

      // ─── BUILD CLUE LISTS ─────────────────────────────────────────────────────────
      const clueEls = {};
      WORDS.forEach((w) => {
        const li = document.createElement("li");
        li.innerHTML = `<span class="cn">${w.label}.</span>${w.clue}`;
        li.addEventListener("click", () => activateWord(w, 0));
        document
          .getElementById(w.dir === "across" ? "clues-across" : "clues-down")
          .appendChild(li);
        clueEls[w.id] = li;
      });

      // ─── CAPTURE INPUT ────────────────────────────────────────────────────────────
      // One hidden input stays permanently focused. All keyboard/mobile input
      // goes through it — no focus juggling, no dropped letters.
      const capture = document.getElementById("capture");

      // Re-focus capture whenever it loses focus (e.g. user taps elsewhere)
      capture.addEventListener("blur", () => {
        // Small delay so tap events on cells fire first
        setTimeout(() => capture.focus(), 50);
      });

      capture.addEventListener("keydown", (e) => {
        if (e.key === "Backspace") {
          e.preventDefault();
          const { r, c } = activeWord.cells[activeCellIdx];
          if (getVal(r, c)) {
            setVal(r, c, "");
          } else {
            retreatInWord();
            const prev = activeWord.cells[activeCellIdx];
            setVal(prev.r, prev.c, "");
          }
          return;
        }
        if (e.key === "ArrowRight") {
          e.preventDefault();
          if (activeWord.dir === "across") advanceInWord();
        }
        if (e.key === "ArrowLeft") {
          e.preventDefault();
          if (activeWord.dir === "across") retreatInWord();
        }
        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (activeWord.dir === "down") advanceInWord();
        }
        if (e.key === "ArrowUp") {
          e.preventDefault();
          if (activeWord.dir === "down") retreatInWord();
        }
      });

      capture.addEventListener("input", (e) => {
        // e.data = the character(s) just typed. Take the last alpha char.
        const raw = e.data ?? capture.value;
        // Always reset the hidden input so it's ready for the next character
        capture.value = "";

        const letter = (raw || "")
          .replace(/[^a-zA-Z]/g, "")
          .slice(-1)
          .toUpperCase();
        if (!letter) return;

        if (!startTime) startTime = Date.now();

        const { r, c } = activeWord.cells[activeCellIdx];
        setVal(r, c, letter);
        advanceInWord();
        checkComplete();
      });

      // Focus the capture input on page load and whenever the grid area is tapped
      document
        .getElementById("grid-wrapper")
        .addEventListener("mousedown", () => capture.focus());
      capture.focus();

      // ─── ACTIVATE WORD ────────────────────────────────────────────────────────────
      function activateWord(word, letterIdx) {
        activeWord = word;
        activeCellIdx = Math.max(0, Math.min(word.cells.length - 1, letterIdx));

        // Clear all highlights
        Object.values(cellEl).forEach((el) =>
          el.classList.remove("hl-word", "hl-active"),
        );

        // Highlight word cells
        word.cells.forEach(({ r, c }) => {
          const el = cellEl[`${r},${c}`];
          if (el) el.classList.add("hl-word");
        });

        // Highlight active cell
        const { r, c } = word.cells[activeCellIdx];
        const el = cellEl[`${r},${c}`];
        if (el) {
          el.classList.remove("hl-word");
          el.classList.add("hl-active");
        }

        // Clue list
        Object.values(clueEls).forEach((li) => li.classList.remove("active"));
        clueEls[word.id].classList.add("active");

        // Keep capture focused
        capture.focus();
      }

      function advanceInWord() {
        if (activeCellIdx < activeWord.cells.length - 1) {
          activateWord(activeWord, activeCellIdx + 1);
        }
      }

      function retreatInWord() {
        if (activeCellIdx > 0) {
          activateWord(activeWord, activeCellIdx - 1);
        }
      }

      // ─── CLICK HANDLER ────────────────────────────────────────────────────────────
      function onCellClick(r, c) {
        const starters = WORDS.filter(
          (w) => w.cells[0].r === r && w.cells[0].c === c,
        );

        if (starters.length === 1) {
          activateWord(starters[0], 0);
          return;
        }
        if (starters.length > 1) {
          // Only (0,0): default to 1A unless full and 1D isn't
          const wa = starters.find((w) => w.dir === "across");
          const wd = starters.find((w) => w.dir === "down");
          if (wa && isWordFilled(wa) && wd && !isWordFilled(wd))
            activateWord(wd, 0);
          else activateWord(wa || starters[0], 0);
          return;
        }

        // Mid-word cell: stay on current word if it contains this cell
        const idxInCurrent = activeWord.cells.findIndex(
          (cell) => cell.r === r && cell.c === c,
        );
        if (idxInCurrent !== -1) {
          activateWord(activeWord, idxInCurrent);
          return;
        }

        // Otherwise find any word that contains it
        for (const w of WORDS) {
          const idx = w.cells.findIndex((cell) => cell.r === r && cell.c === c);
          if (idx !== -1) {
            activateWord(w, idx);
            return;
          }
        }
      }

      // ─── COMPLETION CHECK ─────────────────────────────────────────────────────────
      function checkComplete() {
        if (puzzleDone) return;

        const allFilled = Object.keys(cellEl).every((key) => {
          const [r, c] = key.split(",").map(Number);
          return getVal(r, c) !== "";
        });
        if (!allFilled) return;

        const allCorrect = Object.keys(cellEl).every((key) => {
          const [r, c] = key.split(",").map(Number);
          return getVal(r, c) === SOLUTION[r][c];
        });

        const errorEl = document.getElementById("error-msg");
        const gridWrap = document.getElementById("grid-wrapper");

        if (allCorrect) {
          puzzleDone = true;
          errorEl.classList.remove("show");
          const secs = Math.round((Date.now() - startTime) / 1000);
          const timeStr =
            secs < 60
              ? `in ${secs} second${secs === 1 ? "" : "s"}`
              : `in ${Math.floor(secs / 60)}m ${secs % 60}s`;
          document.getElementById("victory-time").textContent = timeStr;
          document.getElementById("victory-overlay").classList.add("show");
        } else {
          errorEl.classList.add("show");
          if (!hasShaken) {
            hasShaken = true;
            void gridWrap.offsetWidth;
            gridWrap.classList.add("shake");
            gridWrap.addEventListener(
              "animationend",
              () => gridWrap.classList.remove("shake"),
              { once: true },
            );
          }
        }
      }

      // ─── INIT ─────────────────────────────────────────────────────────────────────
      activateWord(WORDS[0], 0);
    </script>
  </body>
</html>
